// Code generated by http://github.com/gojuno/minimock (v3.4.7). DO NOT EDIT.

package mocks

//go:generate minimock -i wallet-app/internal/api/handler/api_1_wallet.Service -o service_mock.go -n ServiceMock -p mocks

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"
	"wallet-app/internal/domain/wallet/models"

	"github.com/gojuno/minimock/v3"
	"github.com/google/uuid"
)

// ServiceMock implements mm_api_1_wallet.Service
type ServiceMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcUpdateBalance          func(ctx context.Context, walletID uuid.UUID, amount int64, opType models.OperationType) (err error)
	funcUpdateBalanceOrigin    string
	inspectFuncUpdateBalance   func(ctx context.Context, walletID uuid.UUID, amount int64, opType models.OperationType)
	afterUpdateBalanceCounter  uint64
	beforeUpdateBalanceCounter uint64
	UpdateBalanceMock          mServiceMockUpdateBalance
}

// NewServiceMock returns a mock for mm_api_1_wallet.Service
func NewServiceMock(t minimock.Tester) *ServiceMock {
	m := &ServiceMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.UpdateBalanceMock = mServiceMockUpdateBalance{mock: m}
	m.UpdateBalanceMock.callArgs = []*ServiceMockUpdateBalanceParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mServiceMockUpdateBalance struct {
	optional           bool
	mock               *ServiceMock
	defaultExpectation *ServiceMockUpdateBalanceExpectation
	expectations       []*ServiceMockUpdateBalanceExpectation

	callArgs []*ServiceMockUpdateBalanceParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ServiceMockUpdateBalanceExpectation specifies expectation struct of the Service.UpdateBalance
type ServiceMockUpdateBalanceExpectation struct {
	mock               *ServiceMock
	params             *ServiceMockUpdateBalanceParams
	paramPtrs          *ServiceMockUpdateBalanceParamPtrs
	expectationOrigins ServiceMockUpdateBalanceExpectationOrigins
	results            *ServiceMockUpdateBalanceResults
	returnOrigin       string
	Counter            uint64
}

// ServiceMockUpdateBalanceParams contains parameters of the Service.UpdateBalance
type ServiceMockUpdateBalanceParams struct {
	ctx      context.Context
	walletID uuid.UUID
	amount   int64
	opType   models.OperationType
}

// ServiceMockUpdateBalanceParamPtrs contains pointers to parameters of the Service.UpdateBalance
type ServiceMockUpdateBalanceParamPtrs struct {
	ctx      *context.Context
	walletID *uuid.UUID
	amount   *int64
	opType   *models.OperationType
}

// ServiceMockUpdateBalanceResults contains results of the Service.UpdateBalance
type ServiceMockUpdateBalanceResults struct {
	err error
}

// ServiceMockUpdateBalanceOrigins contains origins of expectations of the Service.UpdateBalance
type ServiceMockUpdateBalanceExpectationOrigins struct {
	origin         string
	originCtx      string
	originWalletID string
	originAmount   string
	originOpType   string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUpdateBalance *mServiceMockUpdateBalance) Optional() *mServiceMockUpdateBalance {
	mmUpdateBalance.optional = true
	return mmUpdateBalance
}

// Expect sets up expected params for Service.UpdateBalance
func (mmUpdateBalance *mServiceMockUpdateBalance) Expect(ctx context.Context, walletID uuid.UUID, amount int64, opType models.OperationType) *mServiceMockUpdateBalance {
	if mmUpdateBalance.mock.funcUpdateBalance != nil {
		mmUpdateBalance.mock.t.Fatalf("ServiceMock.UpdateBalance mock is already set by Set")
	}

	if mmUpdateBalance.defaultExpectation == nil {
		mmUpdateBalance.defaultExpectation = &ServiceMockUpdateBalanceExpectation{}
	}

	if mmUpdateBalance.defaultExpectation.paramPtrs != nil {
		mmUpdateBalance.mock.t.Fatalf("ServiceMock.UpdateBalance mock is already set by ExpectParams functions")
	}

	mmUpdateBalance.defaultExpectation.params = &ServiceMockUpdateBalanceParams{ctx, walletID, amount, opType}
	mmUpdateBalance.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmUpdateBalance.expectations {
		if minimock.Equal(e.params, mmUpdateBalance.defaultExpectation.params) {
			mmUpdateBalance.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateBalance.defaultExpectation.params)
		}
	}

	return mmUpdateBalance
}

// ExpectCtxParam1 sets up expected param ctx for Service.UpdateBalance
func (mmUpdateBalance *mServiceMockUpdateBalance) ExpectCtxParam1(ctx context.Context) *mServiceMockUpdateBalance {
	if mmUpdateBalance.mock.funcUpdateBalance != nil {
		mmUpdateBalance.mock.t.Fatalf("ServiceMock.UpdateBalance mock is already set by Set")
	}

	if mmUpdateBalance.defaultExpectation == nil {
		mmUpdateBalance.defaultExpectation = &ServiceMockUpdateBalanceExpectation{}
	}

	if mmUpdateBalance.defaultExpectation.params != nil {
		mmUpdateBalance.mock.t.Fatalf("ServiceMock.UpdateBalance mock is already set by Expect")
	}

	if mmUpdateBalance.defaultExpectation.paramPtrs == nil {
		mmUpdateBalance.defaultExpectation.paramPtrs = &ServiceMockUpdateBalanceParamPtrs{}
	}
	mmUpdateBalance.defaultExpectation.paramPtrs.ctx = &ctx
	mmUpdateBalance.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmUpdateBalance
}

// ExpectWalletIDParam2 sets up expected param walletID for Service.UpdateBalance
func (mmUpdateBalance *mServiceMockUpdateBalance) ExpectWalletIDParam2(walletID uuid.UUID) *mServiceMockUpdateBalance {
	if mmUpdateBalance.mock.funcUpdateBalance != nil {
		mmUpdateBalance.mock.t.Fatalf("ServiceMock.UpdateBalance mock is already set by Set")
	}

	if mmUpdateBalance.defaultExpectation == nil {
		mmUpdateBalance.defaultExpectation = &ServiceMockUpdateBalanceExpectation{}
	}

	if mmUpdateBalance.defaultExpectation.params != nil {
		mmUpdateBalance.mock.t.Fatalf("ServiceMock.UpdateBalance mock is already set by Expect")
	}

	if mmUpdateBalance.defaultExpectation.paramPtrs == nil {
		mmUpdateBalance.defaultExpectation.paramPtrs = &ServiceMockUpdateBalanceParamPtrs{}
	}
	mmUpdateBalance.defaultExpectation.paramPtrs.walletID = &walletID
	mmUpdateBalance.defaultExpectation.expectationOrigins.originWalletID = minimock.CallerInfo(1)

	return mmUpdateBalance
}

// ExpectAmountParam3 sets up expected param amount for Service.UpdateBalance
func (mmUpdateBalance *mServiceMockUpdateBalance) ExpectAmountParam3(amount int64) *mServiceMockUpdateBalance {
	if mmUpdateBalance.mock.funcUpdateBalance != nil {
		mmUpdateBalance.mock.t.Fatalf("ServiceMock.UpdateBalance mock is already set by Set")
	}

	if mmUpdateBalance.defaultExpectation == nil {
		mmUpdateBalance.defaultExpectation = &ServiceMockUpdateBalanceExpectation{}
	}

	if mmUpdateBalance.defaultExpectation.params != nil {
		mmUpdateBalance.mock.t.Fatalf("ServiceMock.UpdateBalance mock is already set by Expect")
	}

	if mmUpdateBalance.defaultExpectation.paramPtrs == nil {
		mmUpdateBalance.defaultExpectation.paramPtrs = &ServiceMockUpdateBalanceParamPtrs{}
	}
	mmUpdateBalance.defaultExpectation.paramPtrs.amount = &amount
	mmUpdateBalance.defaultExpectation.expectationOrigins.originAmount = minimock.CallerInfo(1)

	return mmUpdateBalance
}

// ExpectOpTypeParam4 sets up expected param opType for Service.UpdateBalance
func (mmUpdateBalance *mServiceMockUpdateBalance) ExpectOpTypeParam4(opType models.OperationType) *mServiceMockUpdateBalance {
	if mmUpdateBalance.mock.funcUpdateBalance != nil {
		mmUpdateBalance.mock.t.Fatalf("ServiceMock.UpdateBalance mock is already set by Set")
	}

	if mmUpdateBalance.defaultExpectation == nil {
		mmUpdateBalance.defaultExpectation = &ServiceMockUpdateBalanceExpectation{}
	}

	if mmUpdateBalance.defaultExpectation.params != nil {
		mmUpdateBalance.mock.t.Fatalf("ServiceMock.UpdateBalance mock is already set by Expect")
	}

	if mmUpdateBalance.defaultExpectation.paramPtrs == nil {
		mmUpdateBalance.defaultExpectation.paramPtrs = &ServiceMockUpdateBalanceParamPtrs{}
	}
	mmUpdateBalance.defaultExpectation.paramPtrs.opType = &opType
	mmUpdateBalance.defaultExpectation.expectationOrigins.originOpType = minimock.CallerInfo(1)

	return mmUpdateBalance
}

// Inspect accepts an inspector function that has same arguments as the Service.UpdateBalance
func (mmUpdateBalance *mServiceMockUpdateBalance) Inspect(f func(ctx context.Context, walletID uuid.UUID, amount int64, opType models.OperationType)) *mServiceMockUpdateBalance {
	if mmUpdateBalance.mock.inspectFuncUpdateBalance != nil {
		mmUpdateBalance.mock.t.Fatalf("Inspect function is already set for ServiceMock.UpdateBalance")
	}

	mmUpdateBalance.mock.inspectFuncUpdateBalance = f

	return mmUpdateBalance
}

// Return sets up results that will be returned by Service.UpdateBalance
func (mmUpdateBalance *mServiceMockUpdateBalance) Return(err error) *ServiceMock {
	if mmUpdateBalance.mock.funcUpdateBalance != nil {
		mmUpdateBalance.mock.t.Fatalf("ServiceMock.UpdateBalance mock is already set by Set")
	}

	if mmUpdateBalance.defaultExpectation == nil {
		mmUpdateBalance.defaultExpectation = &ServiceMockUpdateBalanceExpectation{mock: mmUpdateBalance.mock}
	}
	mmUpdateBalance.defaultExpectation.results = &ServiceMockUpdateBalanceResults{err}
	mmUpdateBalance.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmUpdateBalance.mock
}

// Set uses given function f to mock the Service.UpdateBalance method
func (mmUpdateBalance *mServiceMockUpdateBalance) Set(f func(ctx context.Context, walletID uuid.UUID, amount int64, opType models.OperationType) (err error)) *ServiceMock {
	if mmUpdateBalance.defaultExpectation != nil {
		mmUpdateBalance.mock.t.Fatalf("Default expectation is already set for the Service.UpdateBalance method")
	}

	if len(mmUpdateBalance.expectations) > 0 {
		mmUpdateBalance.mock.t.Fatalf("Some expectations are already set for the Service.UpdateBalance method")
	}

	mmUpdateBalance.mock.funcUpdateBalance = f
	mmUpdateBalance.mock.funcUpdateBalanceOrigin = minimock.CallerInfo(1)
	return mmUpdateBalance.mock
}

// When sets expectation for the Service.UpdateBalance which will trigger the result defined by the following
// Then helper
func (mmUpdateBalance *mServiceMockUpdateBalance) When(ctx context.Context, walletID uuid.UUID, amount int64, opType models.OperationType) *ServiceMockUpdateBalanceExpectation {
	if mmUpdateBalance.mock.funcUpdateBalance != nil {
		mmUpdateBalance.mock.t.Fatalf("ServiceMock.UpdateBalance mock is already set by Set")
	}

	expectation := &ServiceMockUpdateBalanceExpectation{
		mock:               mmUpdateBalance.mock,
		params:             &ServiceMockUpdateBalanceParams{ctx, walletID, amount, opType},
		expectationOrigins: ServiceMockUpdateBalanceExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmUpdateBalance.expectations = append(mmUpdateBalance.expectations, expectation)
	return expectation
}

// Then sets up Service.UpdateBalance return parameters for the expectation previously defined by the When method
func (e *ServiceMockUpdateBalanceExpectation) Then(err error) *ServiceMock {
	e.results = &ServiceMockUpdateBalanceResults{err}
	return e.mock
}

// Times sets number of times Service.UpdateBalance should be invoked
func (mmUpdateBalance *mServiceMockUpdateBalance) Times(n uint64) *mServiceMockUpdateBalance {
	if n == 0 {
		mmUpdateBalance.mock.t.Fatalf("Times of ServiceMock.UpdateBalance mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpdateBalance.expectedInvocations, n)
	mmUpdateBalance.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmUpdateBalance
}

func (mmUpdateBalance *mServiceMockUpdateBalance) invocationsDone() bool {
	if len(mmUpdateBalance.expectations) == 0 && mmUpdateBalance.defaultExpectation == nil && mmUpdateBalance.mock.funcUpdateBalance == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpdateBalance.mock.afterUpdateBalanceCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpdateBalance.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UpdateBalance implements mm_api_1_wallet.Service
func (mmUpdateBalance *ServiceMock) UpdateBalance(ctx context.Context, walletID uuid.UUID, amount int64, opType models.OperationType) (err error) {
	mm_atomic.AddUint64(&mmUpdateBalance.beforeUpdateBalanceCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateBalance.afterUpdateBalanceCounter, 1)

	mmUpdateBalance.t.Helper()

	if mmUpdateBalance.inspectFuncUpdateBalance != nil {
		mmUpdateBalance.inspectFuncUpdateBalance(ctx, walletID, amount, opType)
	}

	mm_params := ServiceMockUpdateBalanceParams{ctx, walletID, amount, opType}

	// Record call args
	mmUpdateBalance.UpdateBalanceMock.mutex.Lock()
	mmUpdateBalance.UpdateBalanceMock.callArgs = append(mmUpdateBalance.UpdateBalanceMock.callArgs, &mm_params)
	mmUpdateBalance.UpdateBalanceMock.mutex.Unlock()

	for _, e := range mmUpdateBalance.UpdateBalanceMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmUpdateBalance.UpdateBalanceMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateBalance.UpdateBalanceMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateBalance.UpdateBalanceMock.defaultExpectation.params
		mm_want_ptrs := mmUpdateBalance.UpdateBalanceMock.defaultExpectation.paramPtrs

		mm_got := ServiceMockUpdateBalanceParams{ctx, walletID, amount, opType}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpdateBalance.t.Errorf("ServiceMock.UpdateBalance got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateBalance.UpdateBalanceMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.walletID != nil && !minimock.Equal(*mm_want_ptrs.walletID, mm_got.walletID) {
				mmUpdateBalance.t.Errorf("ServiceMock.UpdateBalance got unexpected parameter walletID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateBalance.UpdateBalanceMock.defaultExpectation.expectationOrigins.originWalletID, *mm_want_ptrs.walletID, mm_got.walletID, minimock.Diff(*mm_want_ptrs.walletID, mm_got.walletID))
			}

			if mm_want_ptrs.amount != nil && !minimock.Equal(*mm_want_ptrs.amount, mm_got.amount) {
				mmUpdateBalance.t.Errorf("ServiceMock.UpdateBalance got unexpected parameter amount, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateBalance.UpdateBalanceMock.defaultExpectation.expectationOrigins.originAmount, *mm_want_ptrs.amount, mm_got.amount, minimock.Diff(*mm_want_ptrs.amount, mm_got.amount))
			}

			if mm_want_ptrs.opType != nil && !minimock.Equal(*mm_want_ptrs.opType, mm_got.opType) {
				mmUpdateBalance.t.Errorf("ServiceMock.UpdateBalance got unexpected parameter opType, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateBalance.UpdateBalanceMock.defaultExpectation.expectationOrigins.originOpType, *mm_want_ptrs.opType, mm_got.opType, minimock.Diff(*mm_want_ptrs.opType, mm_got.opType))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateBalance.t.Errorf("ServiceMock.UpdateBalance got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmUpdateBalance.UpdateBalanceMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdateBalance.UpdateBalanceMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdateBalance.t.Fatal("No results are set for the ServiceMock.UpdateBalance")
		}
		return (*mm_results).err
	}
	if mmUpdateBalance.funcUpdateBalance != nil {
		return mmUpdateBalance.funcUpdateBalance(ctx, walletID, amount, opType)
	}
	mmUpdateBalance.t.Fatalf("Unexpected call to ServiceMock.UpdateBalance. %v %v %v %v", ctx, walletID, amount, opType)
	return
}

// UpdateBalanceAfterCounter returns a count of finished ServiceMock.UpdateBalance invocations
func (mmUpdateBalance *ServiceMock) UpdateBalanceAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateBalance.afterUpdateBalanceCounter)
}

// UpdateBalanceBeforeCounter returns a count of ServiceMock.UpdateBalance invocations
func (mmUpdateBalance *ServiceMock) UpdateBalanceBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateBalance.beforeUpdateBalanceCounter)
}

// Calls returns a list of arguments used in each call to ServiceMock.UpdateBalance.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateBalance *mServiceMockUpdateBalance) Calls() []*ServiceMockUpdateBalanceParams {
	mmUpdateBalance.mutex.RLock()

	argCopy := make([]*ServiceMockUpdateBalanceParams, len(mmUpdateBalance.callArgs))
	copy(argCopy, mmUpdateBalance.callArgs)

	mmUpdateBalance.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateBalanceDone returns true if the count of the UpdateBalance invocations corresponds
// the number of defined expectations
func (m *ServiceMock) MinimockUpdateBalanceDone() bool {
	if m.UpdateBalanceMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UpdateBalanceMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpdateBalanceMock.invocationsDone()
}

// MinimockUpdateBalanceInspect logs each unmet expectation
func (m *ServiceMock) MinimockUpdateBalanceInspect() {
	for _, e := range m.UpdateBalanceMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ServiceMock.UpdateBalance at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterUpdateBalanceCounter := mm_atomic.LoadUint64(&m.afterUpdateBalanceCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateBalanceMock.defaultExpectation != nil && afterUpdateBalanceCounter < 1 {
		if m.UpdateBalanceMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ServiceMock.UpdateBalance at\n%s", m.UpdateBalanceMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ServiceMock.UpdateBalance at\n%s with params: %#v", m.UpdateBalanceMock.defaultExpectation.expectationOrigins.origin, *m.UpdateBalanceMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateBalance != nil && afterUpdateBalanceCounter < 1 {
		m.t.Errorf("Expected call to ServiceMock.UpdateBalance at\n%s", m.funcUpdateBalanceOrigin)
	}

	if !m.UpdateBalanceMock.invocationsDone() && afterUpdateBalanceCounter > 0 {
		m.t.Errorf("Expected %d calls to ServiceMock.UpdateBalance at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.UpdateBalanceMock.expectedInvocations), m.UpdateBalanceMock.expectedInvocationsOrigin, afterUpdateBalanceCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *ServiceMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockUpdateBalanceInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *ServiceMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *ServiceMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockUpdateBalanceDone()
}
